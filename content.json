{"posts":[{"title":"Beginning","text":"博主大三上结束，时间充裕起来了，准备在寒假完成接下来的三篇论文就开始写点博客玩玩。 本博客会分享技术和生活方面的文章。由于我研究方向是密码学，并且目前国内密码学优质的文章确实太少，目前准备主要更新密码学相关的文章，希望能帮助到想要入门的大伙（光是入门就太难辣）。之后随着研究领域扩宽会加一些其他研究方向的分享。生活方面会有一些其他杂七杂八的内容，包括但不限于对去去过的饭店、酒吧、动漫的评价。","link":"/2023/11/08/2022.12.14%20Beginning/"},{"title":"去中心化身份和Web3","text":"最近在看去中心化身份（DID）和Web3，在这里写一篇笔记。说实话，这个领域目前还处于摸索阶段，真正落地的项目不多。刚接触的人对Web3.0的描述只能停留于加密货币、区块链、去中心化、数据所有权、反垄断等花里胡哨的关键词（蛮符合我对区块链的刻板印象的）。 Web3和DID的关联我认为，Web3就是为了解决一个issue：数据归于用户。比如用户在注册中心化平台账号时一般需要给平台提供手机号等身份信息，一些服务甚至还需要提供身份证进行实名认证，这导致了用户数据的主动权泄露给了服务器。在Web3，用户不需要将他们的数据存储到中心化平台，避免了自己数据资产被中心化实体控制的风险，自己享有数据的使用权。 DID的诞生和Web3类似，用户登录不同的中心化网站需要注册账户，不同网站的身份系统不互通。即使现在登录中心化网站可以使用联邦身份，支持使用微信、QQ账号进行第三方登录，但是第三方登陆后往往也需要用户输入手机号+验证码来注册。中心化身份想要让用户在网络空间中具有一种全局唯一的身份，用户在使用任何平台的服务时，用这种标识符来进行登录或者身份验证。 乍一看，两者的思想是非常相似的。Web3是想要数据归于用户，DID具体实现了身份信息归于用户，所以DID是Web3的一种实现。而DID可以解决Web3的身份验证问题，所以DID也是组成Web3的一种关键技术。Web3的数字钱包地址也可以整合到DID中从而标识钱包的所有权 DID从W3C的规范来谈，DID包含标识符和文档，标识符负责表示全局唯一的身份，文档包含和这个数字身份的相关的数据。平台通过DID对用户进行认证。如果平台需要认证用户额外的信息，比如用户的年龄，用户需要向政府部门请求关于年龄的可验证声明，政府部门向用户返回声明后，用户向平台发送声明，如果声明的验证通过并且DID的验证通过，则用户在该平台登录成功，或者说认证成功。 这里补充一下，用户的DID文档是存储在区块链上的 DID具体结构DID标识符是全局唯一表示身份的key，举个例子：did:eth:123456789abcdefg DID文档是用来存储和这个身份相关联的数据 ，目前一般使用JSON字符串，其中至少包含：DID标识符、公钥、支持的加密协议、服务的功能及其对应的URL，时间戳，证明DID合法的签名。一个符合W3C标准的基本DID文档如下所示 ： 1234567891011121314151617{ &quot;@context&quot;: &quot;https://w3id.org/did/v1&quot;, &quot;id&quot;: &quot;did:example:123456789abcdefghi&quot;, // DID标识符 &quot;authentication&quot;: [{ // 用于验证DID的参数 &quot;id&quot;: &quot;did:example:123456789abcdefghi#keys-1&quot;, &quot;type&quot;: &quot;RsaVerificationKey2018&quot;, &quot;controller&quot;: &quot;did:example:123456789abcdefghi&quot;, &quot;publicKeyPem&quot;: &quot;-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\\r\\n&quot; }], &quot;service&quot;: [{ // 服务集合，下列服务用于返回和DID相关的可验证声明 &quot;id&quot;:&quot;did:example:123456789abcdefghi#vcs&quot;, &quot;type&quot;: &quot;VerifiableCredentialService&quot;, &quot;serviceEndpoint&quot;: &quot;https://example.com/vc/&quot; }]} 可以看到DID文档中并没有和真实身份相关联的信息。如果平台需要验证用户年龄、用户手机号等信息，单独靠DID是不能完成的，需要权威机构开具可验证声明。 可验证声明可验证声明系统是DID的一部分，本质上就是一个PKI体系。一个可验证声明系统有四个实体： 发行者（Issuer）：拥有用户数据，并且能够开局可验证声明 (Verifiable Credential, VC) 的实体，比如政府。 验证者（Inspector-Verifier, IV）：负责提供服务，但是在提供服务之前需要验证VC 持有者（Holder）：向Issuer请求VC的实体，它可以将开具的VC存到数字钱包中 标识符注册机构（Identifier Registry）：负责提供注册DID，维护DID服务的实体，如某条区块链 可以看到DID和VC其实是分开的。 当用户需要使用某个平台的服务，平台需要用户出示证明自己已满18岁。这时用户需要向Issuer请求对应的VC，Issuer返回VC后用户将VC存储在数字钱包中并发送给平台。平台对VC验证通过就允许用户使用服务。VC可以重复使用，只要VC还在有效期内，用户就可以一直使用VC来表明自己已满18岁。W3C提供的VC参考如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849{ // set the context, which establishes the special terms we will be using // such as 'issuer' and 'alumniOf'. &quot;@context&quot;: [ &quot;https://www.w3.org/2018/credentials/v1&quot;, &quot;https://www.w3.org/2018/credentials/examples/v1&quot; ], // specify the identifier for the credential &quot;id&quot;: &quot;http://example.edu/credentials/1872&quot;, // the credential types, which declare what data to expect in the credential &quot;type&quot;: [&quot;VerifiableCredential&quot;, &quot;AlumniCredential&quot;], // the entity that issued the credential &quot;issuer&quot;: &quot;https://example.edu/issuers/565049&quot;, // when the credential was issued &quot;issuanceDate&quot;: &quot;2010-01-01T19:73:24Z&quot;, // claims about the subjects of the credential &quot;credentialSubject&quot;: { // identifier for the only subject of the credential &quot;id&quot;: &quot;did:example:ebfeb1f712ebc6f1c276e12ec21&quot;, // assertion about the only subject of the credential &quot;alumniOf&quot;: { &quot;id&quot;: &quot;did:example:c276e12ec21ebfeb1f712ebc6f1&quot;, &quot;name&quot;: [{ &quot;value&quot;: &quot;Example University&quot;, &quot;lang&quot;: &quot;en&quot; }, { &quot;value&quot;: &quot;Exemple d'Université&quot;, &quot;lang&quot;: &quot;fr&quot; }] } }, // digital proof that makes the credential tamper-evident // see the NOTE at end of this section for more detail &quot;proof&quot;: { // the cryptographic signature suite that was used to generate the signature &quot;type&quot;: &quot;RsaSignature2018&quot;, // the date the signature was created &quot;created&quot;: &quot;2017-06-18T21:19:10Z&quot;, // purpose of this proof &quot;proofPurpose&quot;: &quot;assertionMethod&quot;, // the identifier of the public key that can verify the signature &quot;verificationMethod&quot;: &quot;https://example.edu/issuers/keys/1&quot;, // the digital signature value &quot;jws&quot;: &quot;eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5X sITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUc X16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtj PAYuNzVBAh4vGHSrQyHUdBBPM&quot; }} VC的id是一个URI，而VC中的Issuer字段也是一个URI。而Issuer也可能是使用DID来作为其身份的。因此通过VC中的Issuer字段——URI地址得到Issuer的DID，然后从对应的DID文档里就可以得到Issuer的公钥。VI可以用公钥验证对VC的签名，就能验证VC是否Issuer发的。 一些QA Q1：DID系统中哪些东西需要上链，哪些东西需要私下保存？ A1：DID标识符和文档需要上链。目前VC因为包含了用户的隐私信息，需要私下保存。但是即使是私下保存VC，把VC发给平台认证的时候依然会把隐私信息泄露给平台，这个我认为可以使用公钥密码的技术来解决这个问题。 Q2：使用了Web3和DID是否就能自己掌握数据和帐号了？ A1：我认为只是做了改进，自己完全掌握自己的数据和账号是不现实的。 DID中自己的信息依然存储在中心化机构。相比于中心化身份，DID的身份信息只保存在给用户颁发对应身份信息的机构中（比如政府颁发身份证号，银行颁发银行卡号，运营商颁发手机号）。中心化身份的身份信息既保存在颁发身份信息的机构中，也保存在中心化平台中（因为用户注册需要提供相关信息）。如果颁发身份信息的机构可信，那用户就完全具有了对身份数据的控制权。 其次，用户在平台上的行为数据依然全部被这个网站所拥有，但是用户最关键的身份信息不会透露给中心化网站，用户可以使用VC的方式来披露部分身份信息（比如之前的例子，自己是否已满18周岁） DID确实有保护隐私的作用，DID中不存有用户任何和现实身份有关的信息，如果真需要对现实身份信息进行认证，就需要Issuer开具VC。在DID中研究隐私保护其实就是在VC中研究如何保护用户数据隐私 Q3：DID真的能火起来吗？ A3：我对此比较怀疑，从受众角度来讲，这改变了用户使用互联网的习惯，这需要有公司提供软件对Web3和DID技术做足够的封装，帮助用户一键处理麻烦的步骤（包括但不限于申请DID并上链，申请VC并保存到本地等），如果能在保证用户使用体验的情况下保护用户隐私那可能会吸引一部分受众，但是使用区块链就决定了小众且低效；从标准角度来讲，目前并没有能够颁发大家都信服的Web3和DID标准，这会阻挠DID的基础设施建设；从基础设施来讲，这会损害现有中心化平台的利益，对于能从中心化平台牟利的公司来说应该不会积极开发DID的技术以及相关基础设施的建设（比如Web3的密钥管理，协议建设等）。 DID的隐私问题隐私是Web3去中心化和数据主权之后的第三大目标，我认为现有Web3的隐私问题和改进主要有以下几点（从密码学角度来说，可能比较严格）： 较多用户有分享的习惯，在使用平台服务时，他们可能会以DID的名义分享和自己真实身份相关的信息，造成隐私泄露。但这是用户习惯造成的，很难避免。 在使用VC进行验证时有暴露用户身份信息的风险 用户在使用数字钱包进行数据共享时，需要对数据进行细粒度的访问控制 能否在Issuer生成可验证声明时不知道这个可验证声明是什么 密码学天生就是为了隐私保护而生的，目前利用密码学技术来解决DID的隐私问题具有很大的研究空间。比如 各种通用的隐私计算技术：比如使用零知识证明当用户使用VC进行认证时VC不包含用户的隐私信息，但是平台能知道用户有对应的隐私信息能够满足认证要求。 门限加密，身份基加密，属性基加密：为用户使用数字钱包进行数据共享时提供细粒度的访问控制。 群签名、环签名、盲签名：虽然在区块链中还是环签名用的最多，但是Web3.0的DID隐私可能会为群签名和盲签名注入新的活力，比如保证用户使用平台服务的匿名性，但是当用户做出违法操作时可以追踪到具体用户；用户想让Issuer生成VC并且Issuer知道用户想对什么信息生成VC，同时Issuer还能知晓用户申请的VC是合规的。 总结Web3+DID是区块链技术的一种新的应用，能够让用户的身份数据以及一些其他的数据归用户所有，由用户决定是否把自己的数据发送给平台。它具有去中心化，数据主权，隐私保护，验证等比较吸引研究人员的特点。 但是在多数用到了区块链的解决方案上，往往都能用目前比较成熟的技术的另一个方案（除了数字货币本身）。而且区块链往往确实没有特别的优势。只要是这样，由于惰性的存在，区块链的落地就很难进行。而且目前大多数人关注区块链不是因为他有去中心化等花里胡哨的性质，而是他们能炒币赚钱割韭菜，真正适合区块链的应用场景依然有待探索（我对在金融领域的探索依然抱有信心，其他的领域就不一定了）。","link":"/2023/11/08/2022.12.30Web3%20DID/"},{"title":"关于利用AI模型传递密码学公钥等公共参数的方法","text":"这个问题来源于我做的IDEA：AI模型版权认证，我们想利用AI模型中的权重来传递公共参数，实现基于零知识证明的可证明安全的版权认证（当然这个思想除了版权认证，肯定还有一些其他的应用场景）。但是这里有个challenge，由于模型本就可以通过重训练等方式修改权重，攻击者完全可以破坏模型中嵌入的公钥，即使攻击者只破坏了少量的bit，依然会导致传递的公钥不可用。这个challenge如何解决呢？ 具体的方法先卖个关子，等我CCS中了再公布吧","link":"/2023/11/08/2023.1.3%E5%85%B3%E4%BA%8E%E5%88%A9%E7%94%A8AI%E6%A8%A1%E5%9E%8B%E4%BC%A0%E9%80%92%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%AC%E9%92%A5%E7%AD%89%E5%85%AC%E5%85%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%9E%E6%B3%95/"},{"title":"Audio音频入门","text":"在反复纠结两个月后，本人最后还是选择之后整音频方向，以后会将自己学音频相关的笔记放到博客上，先学习音频分类吧。 最后吐槽一下：密码学真的是Bar又高又吃不饱饭，虽然有20和21年很多大厂在政策影响下招了隐私计算岗，但这几年已经不会再招多少人了（几乎只有蚂蚁和华为有位置），区块链厂更不说了主打的就是不稳定。 1. 音频基本介绍音频一般指人耳可以听到的频率在20Hz-20kHz之间的声波，也可以指像.WAV这样存储音频信息的文件。它有如下三要素： 振幅：声波振动大小，也就是响度 频率：声波振动的频率，可以理解为音调 波形：决定声波的形状，可以决定声音的音色 1.1. 音频数据的存储方式一般来说，使用脉冲编码调制（PCM）来编码音频，它对连续变化的模拟信号进行抽样、量化和编码产生数字信号。 抽样：将连续时间模拟信号变为离散时间、连续幅度的抽样信号 量化：将抽样信号变为离散时间、离散幅度的数字信号 编码：对每组数据的幅度进行编码 此外还有几个相关概念： 采样率：记录声音时每秒的采样个数，它用赫兹(Hz)来表示。 量化格式（采样深度）：指记录声音的动态范围，它以位(Bit)为单位。 声道数：通道的数目 比特率：每秒传输的数据量，比特率/码率 = 采样率 × 采样深度 × 通道数。kbps 音频编码：仅仅由0和1构成的编码表示不同的振幅 声道数：每次生成一个声波数据成为单声道，每次生成两个声波数据称为双声道 音频率：比特率/8 1.2. 语谱图、Fbank、MFCC之间的关系一般来说，将音频数据输入到神经网络中需要将其预处理为语谱图（log谱）、Fbank或者MFCC，目前为了让神经网络接收到的信息足够多，一般还需要将音频的相位谱也作为输入传输到神经网络中，此时神经网络的输入大小为$B\\times 2\\times W\\times T$，$B$为batch，2为语谱图/Fbank/MFCC和相位谱，$W$为频率范围，$T$为时间。 2. 从音频到语谱图预加重、预增强预增强以帧单位进行，目的在于加强高频，增加语音的高频分辨率。预加重后的结果为 $$ s(x)=s(x)-k*s(x-1) $$ $k$是与增强系数，范围$[0,1)$，常用0.97，$x$是提取的wav时域数组的项 分帧分帧是将不定长的音频切分成固定长度的小段，现实中大多数信号都是非平稳的，但大多数短时间内可以近似看做是平稳的，可以用短时傅里叶变换表现非平稳信号频域特征。 需要分帧是因为后续的傅里叶变换适用于分析平稳的信号，而语音信号是变化迅速的 。 为了避免窗边界对信号的遗漏，因此对帧做偏移时候，帧间要有重叠一部分。通常的选择是帧长25ms，帧移为10ms。接下来的操作是对单帧进行的。要分帧是因为语音信号是快速变化的，而傅里叶变换适用于分析平稳的信号。帧和帧之间的时间差常常取为10ms，这样帧与帧之间会有重叠，否则，由于帧与帧连接处的信号会因为加窗而被弱化，这部分的信息就丢失了。 加窗傅里叶变换要求输入信号是平稳的，但是语音信号从整体上来讲是不平稳的。每帧信号通常要与一个平滑的窗函数相乘，让帧两端平滑地衰减到零，这样可以降低傅里叶变换后旁瓣的强度，取得更高质量的频谱。 分帧截断时域信号的两旁会出现旁瓣，导致频谱泄露。因为声音信号是非周期信号，截取任意有限长的序列都不能代表原信号，矩形窗的频域是Sa函数，旁瓣起伏大，会产生频谱失真。所以一般采用汉明窗，它具有较小的旁瓣。以下是一个窗函数的示例 将窗函数和原始信号相乘就可以获得截取后的信号 $y(t)$。 $$y(t)=x(t)\\cdot w(t-\\tau)$$ 之后对分帧后的每个帧都用这样的窗函数处理，就可以将每帧两侧的旁瓣减弱，经过傅里叶变换后，可以获得更高质量的频谱。 快速傅里叶变换即使是分帧过后极短时间的声音，仍是很多高低频声音的混杂，此时的数据是时域，通过傅里叶变换转换为频域可以将复杂声波分成各种频率的声波，方便神经网络进行学习。最终结果是个频率范围内的重要程度（能量）。 因为我们用的是数字音频，所以我们用到的是离散傅里叶变换。我们现在可以在每一帧上做N点FFT来计算频谱，也称为短时傅里叶变换(Short-Time Fourier-Transform, STFT)，其中N通常为256或512,NFFT = 512。公式如下所示，其中$x_i$为信号$x$的第$i$帧： $$P=\\frac{|FFT(x_i)|^2}{N}$$ 将得到的每一帧的变换按轴频率轴拼接在一起就成了语谱图。纵轴表示频率，横轴表示时间，颜色的深浅来代替频谱强度。 3. 从语谱图到Fbank人耳对声音频谱的响应是非线性的，如果我们能类似于人耳的方式对音频进行处理，可以提高语音识别的性能。耳蜗的滤波作用是在对数频率尺度上进行的，在1000HZ以下为线性尺度，1K HZ以上为对数尺度，使得人耳对低频信号敏感，高频信号不敏感。FilterBank就是这样的一种算法。FBank特征提取要在预处理之后进行，这时语音已经分帧，我们需要逐帧提取FBank特征。生成Fbank需要对频谱图进行对Mel滤波和对数运算。 Mel滤波器组梅尔标度被提出，它是频率Hz的非线性变换，对于以mel scale为单位的信号，可以做到人们对于相同频率差别的信号的感知能力几乎相同。梅尔频率与实际频率的关系为：Hz ($f$) 和 Mel ($m$)，$m=F_{mel}(f)=2595\\cdot log_{10}(1+\\frac{f}{700}), f=F^{-1}_{mel}(m)=700(10^{m/2595}-1)$ 计算fbank的最后一步是在得到的功率谱上应用三角形滤波器，通常是40个滤波器。滤波器如下所示： 当声波频率小于$f(0)$或大于$f(6)$时，滤波器组的和等于0，该声波会被完全过滤掉 确定这些$f(1)～f(6)$需要以最低频率$f_l$，最高频率$f_h$，傅里叶变换时的长度$N$，音频采样率$f_s$，对于第$m$个点$f(m)$计算如下： $$f(m)=(\\frac{N}{f_s})F^{-1}{mel}(F{mel}(f_l)+m\\frac{F_{mel}(f_h)-F_{mel}(f_l)}{M+1})$$ 将Mel滤波器组应用于信号的语谱图（也就是语谱图的矩阵和Mel滤波器的矩阵相乘），然后过滤后的语谱图取$log_{10}$再乘20，得到fbank，fbank的纵坐标表示在某个帧内，不同的滤波器的过滤后并取对数的结果：$s(m)=20*log(f(m))$ 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243def mel_filter(frame_pow, fs, n_filter, nfft): &quot;&quot;&quot; mel 滤波器系数计算 :param frame_pow: 分帧信号功率谱 :param fs: 采样率 hz :param n_filter: 滤波器个数 :param nfft: fft点数 :return: 分帧信号功率谱mel滤波后的值的对数值 mel = 2595 * log10(1 + f/700) # 频率到mel值映射 f = 700 * (10^(m/2595) - 1 # mel值到频率映射 上述过程本质上是对频率f对数化 &quot;&quot;&quot; mel_min = 0 # 最低mel值 mel_max = 2595 * np.log10(1 + fs / 2.0 / 700) # 最高mel值，最大信号频率为 fs/2 mel_points = np.linspace(mel_min, mel_max, n_filter + 2) # n_filter个mel值均匀分布与最低与最高mel值之间 hz_points = 700 * (10 ** (mel_points / 2595.0) - 1) # mel值对应回频率点，频率间隔指数化 filter_edge = np.floor(hz_points * (nfft + 1) / fs) # 对应到fft的点数比例上 # 求mel滤波器系数 fbank = np.zeros((n_filter, int(nfft / 2 + 1))) for m in range(1, 1 + n_filter): f_left = int(filter_edge[m - 1]) # 左边界点 f_center = int(filter_edge[m]) # 中心点 f_right = int(filter_edge[m + 1]) # 右边界点 for k in range(f_left, f_center): fbank[m - 1, k] = (k - f_left) / (f_center - f_left) for k in range(f_center, f_right): fbank[m - 1, k] = (f_right - k) / (f_right - f_center) # mel 滤波 # [num_frame, nfft/2 + 1] * [nfft/2 + 1, n_filter] = [num_frame, n_filter] filter_banks = np.dot(frame_pow, fbank.T) filter_banks = np.where(filter_banks == 0, np.finfo(float).eps, filter_banks) # 取对数 filter_banks = 20 * np.log10(filter_banks) # dB return filter_banks# mel 滤波n_filter = 40 # mel滤波器个数filter_banks = mel_filter(frame_pow, fs, n_filter, nfft)plot_spectrogram(filter_banks.T, ylabel='Filter Banks') 4. 从Fbank到MFCC事实证明，前一步计算出的滤波器组系数高度相关，这在某些机器学习算法中可能存在问题。因此，我们可以应用离散余弦变换（DCT）去相关滤波器组系数并产生滤波器组的压缩表示（用cos函数的值作为系数，求对每个滤波器的取对数输出的加权和），其中$L$是MFCC系数阶数，一般取12-16。$$C(n)=\\sum^{M-1}_{m=0}s(m)cos(\\frac{\\pi n(m-0.5)}{M}),n=1,2,…,L$$","link":"/2023/11/08/2023.10.12%20%E9%9F%B3%E9%A2%91%E5%85%A5%E9%97%A8/"},{"title":"从零开始的属性基加密（一）","text":"吹了这么多牛，还是要讲具体技术的，就从我最早接触的属性基加密 (Attribute-based Encryption, ABE) 开始吧，第一篇文章主要讲属性基加密的基本概念，包括属性基加密是什么，需要用到哪些前置知识。 什么是属性基加密相比于传统的加密，属性基加密能提供细粒度的访问控制（由于我主要搞的是CP-ABE，所以接下来只介绍密文策略属性基加密CP-ABE）。属性基加密系统中有四个实体：数据拥有者DO，数据使用者DU，属性权威AA，云服务器CSP。 虽然目前理论研究早在2015年就达到了巅峰，但由于其出色的访问控制功能，目前依然有很多学者研究具有扩展功能的CP-ABE（策略隐藏、可撤销、可更新、可追踪、多权威等）。 前置知识","link":"/2023/11/08/2023.1.4%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%8A%A0%E5%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"和自己和解","text":"仔细想想，自己因为准备保研已经半年没有更新过博客了。这半年时间发生了很多事，我的心路历程如下：自信满满充满希望 -&gt; 不紧不慢 -&gt; 备受打击 -&gt; 接受平凡。我这篇文章并不是想写一篇保研经验贴，而是分享一下这段时间的感想：人的一切焦虑的根源是自己的价值观和错误的定位，接受自己的平凡，跳出小圈子，即时休息和自己和解才是真理。 这些感想是由于我这半年来受到不能去梦导那里读研和来自绿群peer pressure的焦虑造成的，这篇文章没有任何诋毁绿群的意思，绿群里面的群友给了我很多很多的有用信息，我也因此发自内心的感谢绿群。 从梦导这聊起吧，梦导在某top2，人品好、产出高、conn足、title好是个学生都会心动。在六月以前他说我有机会读他的硕，我也一直在为这个目标采取包括投论文、背面经、刷算法等一系列行动。那段时间我整个人都变得很惶恐，一边在幻想着读研进组的生活，一边在害怕最后没有去梦导那里怎么办。正当我还在认真准备夏令营时，他给我说今年他没有硕士名额，直博人选已经定好了。虽然当时用之后不用焦虑了来安慰自己，但是这给我的挫败感比今年论文被疯狂拒稿还要大，导致这成了我心中的一根刺，时不时就来恶意中伤我一下。之后我也尝试随便套一下信工所的导，但好像套磁的时候选到信工所最强的导了，拿着CCS在投被他官回更给我整不自信了。最后，我兜兜转转去了北深并且研究方向从应用密码变成了AI。这是否是一个好的决定呢？我也不知道，留给时间来检验吧，自己选的路后悔了也没法。 然后是绿群，那是每年全国计算机保研的头部大佬聚集的地方，有985rk1的，有已经中了顶会的，感觉他们这些人聊的学校都是华五起步。此外我还看到了几个学院的tier图，大概是清叉、清贵、北叉、北智在T0的样子，当时会让我觉得非去其中一个不可，不然感觉就像是罪过一样，这导致我没找清楚自己的定位，实际上我本来就不是保研的头部选手，没rank，只有在投的论文，根本不能和清北本还有985头部的同学竞争，树立自己达不到的目标只会徒增烦恼罢了。但显然那时候的我没有明白这一点，只觉得别人入营了清叉、贵系我也应该入营，却没有看到别人付出了比自己多得多的努力，导致我因peer pressure而整天郁郁寡欢。再次声明：我很感谢绿群里面的兄弟们，这些问题主要是因为我没找到定位造成的，和绿群本身无关。 在长达数月的内耗后，我学会了和自己和解，也学会了正确看待peer pressure。接下来我会分享一下和自己和解的方法，这不是逃避，而是一种正视自己的方式，毕竟自己放弃根本就追逐不到的东西也不算逃避。 如何与自己和解： 树立相对正确的价值观：由于评价体系的多样化，我们不能说哪种价值观就是绝对正确的，只能说找到相对正确有泛化性的价值观。局限的价值观是小圈子的通病。以保研为例，绿群那些大佬会给人一种错觉，保研没保到华五就是原罪。但这种价值观只是在绿群这个小圈子里的偶然现象。 眼光放到绿群以外，在自己的学院内，在整个计算机专业大学生群体内，能保研的都算很优秀的那批人了，并不能说没有上华五自己就是菜。在计算机行业内，目前而言只要本硕都在23所高校内 ，那就业是不会被卡title的，企业里面也没有中九华五之类的说法，一切都是自己对小圈子内规定的莫名奇妙的title（末九、次九、中九、上九、华五、清北T0的学院）的执念，出来之后几乎没人会这样细分·。又以科研为例，其实论文没中也不是啥大事，对自己也没太大的影响，在毕业、算法岗和评职称以外，其他的人根本不会关注你的论文成果咋样。 正确认识自己的定位：得根据自己的实力给自己一个大致的定位，不要定过分超过自己定位的目标。比如我这种保研中上水平的，如果目标是进叉院和贵系，那这也太搞了，这会让自己始终不能reach到目标而处于焦虑中。 在合适的地方休息：不可否认，自身的努力可以实现小层级（不能叫阶级）的跨越。但你从上一个层级跨越到更高的层级时，你会感受到从鸡头到凤尾的落差感。这样的落差感可能会使得你继续用更多的努力成为这一层的头，进而再成为下一个层级的尾。但天外有天，层级的跨越几乎可以说是无止境的，我觉得还是得找个合理的自己想要的目标层级，为此努力。达到目标或实在卷不动了就休息下，没必要勉强自己，自己身心健康才是最重要的，一路上能跨越这么多层级已经很厉害了。","link":"/2023/11/08/2023.10.8%20%E5%92%8C%E8%87%AA%E5%B7%B1%E5%92%8C%E8%A7%A3/"},{"title":"论文理解——Proactive Deepfake Defence via Identity Watermarking","text":"来点Deepfake 1. 文章要素1.1. 背景现有deepfake检测技术分为被动检测和主动检测两种。 被动检测依赖于deepfake中留下的伪影，通过判断图片是否存在伪影来判定图片是否被deepfake。这些伪影可能包括颜色失真、局部斑块等空间信息，和眨眼、不一致的头部和嘴部运动来检测伪影。 主动检测 [1, 2, 3, 4] 依赖于水印，通过在原始图像中嵌入一个不可见的水印来对抗恶意的Deepfake，并保证标签在被Deepfake后任然可以被检索到。 1.2. 动机被动检测技术会面临两个问题： 泛化性不足，在应对未知攻击的表现不佳，且Deepfake技术愈发成熟，伪影会越来越少 裁剪、压缩等传统的图像操作会破坏Deepfake的伪影，降低检测的可靠性 这些问题就是主动检测的优势，即使有更高级的deepfake技术，主动检测大概也是能抵御的 1.3. 方法概述将水印嵌入到图像的身份向量中，并重构图像。 输入图像会经过属性编码器提取出一些图片背景信息（姿态、表情等）作为属性，从身份编码器提取出人脸的关键信息作为身份。身份和水印相加，然后和属性一起输入进生成器重新生成该图像。如果之后图像被Deepfake，那么嵌入在身份信息中的水印会被破坏，导致和最初的水印没有相关性检测失败。如果图像没有被Deepfake，那么就可以从最初水印中检测出相关性，进而检测成功。 1.4. 贡献 一种新的主动深度伪造检测方法，将防伪水印嵌入到图像的身份向量中 简单有效的编码器-解码器网络实现不可见的反Deepfake水印 实验效果好（说了当没说） 2. 大致方法2.1. 水印嵌入2.1.1. 特征解纠缠将图像的信息通过两个编码器分为属性$z_{att}(X)$和身份信息$z_{id}(X)=Arc(X)$。 2.1.2. 身份水印嵌入将身份信息$z_{id}(X)$和水印$z_{seq}$相加，其中添加水印的权重为0.1，生成被嵌入水印的身份信息$z^{w}{id}(X),z^{w}{id}(X)=z_{id}(X)+\\alpha z_{seq}$。 2.1.3. 图像重构将被嵌入水印的身份信息$z^{w}{id}(X)$和属性信息$z{att}(X)$输入到生成器中，重构出被嵌入水印的图像$\\hat{X}=Gen(z^{w}{id}(X),z{att}(X))$。 2.2. 水印检测2.2.1. 水印提取将可疑的图像输入到身份编码器中，获取嵌入水印的身份编码信息。提取公式如下所示 $$ z_{id}(\\hat X)=Arc(\\hat X)\\\\ \\approx Arc(Gen(z_{id}(X)+\\alpha z_{zeq},z_{att}(X)))\\\\ \\approx z_{id}(X)+\\alpha z_{seq} $$ 如果$\\hat X$没有被deepfake，那么下面的约等号成立。 2.2.2. 水印验证验证时需要用到相关性函数 $$ Corr[l]=\\sum^{N-1}_{n=0}z_{id}(\\hat X)[n]*z_{seq}[n-l+N-1]\\\\ \\approx\\sum^{N-1}_{n=0}(z_{id}(X)[n]+\\alpha z_{seq}[n])*z_{seq}[k]\\\\ =\\sum^{N-1}_{n=0}z_{id}(X)[n]*z_{seq}[k]+\\alpha z_{seq}[n]*z_{seq}[k], k=n-l+N-1 $$ 当$k=n$，即$l=N-1$时取最大值，此时$Corr$会有很明显的峰值，如果有峰值就能说明水印存在。 2.3. 损失函数本方案需要有四个目标： 重构的图像足够逼真 从重构图像中提取的属性和从原始图像中提取的属性应该尽可能接近 重构图像的特征和原始图像的特征之间的距离应尽可能接近 水印序列在重构图像中应有较好的保真度 这对应了四个损失函数 $Adversarial\\ Loss:\\ L_{adv}=log\\ Dis(X)+log(1-Dis(\\hat X))$，$Dis()$是多尺度鉴别器[5]，要让Gan中的鉴别器难以识别出来 $Attribute\\ Preservation\\ Loss:\\ L_{Att}=1/2\\sum^{n}{k=1}||z^{k}{att}(X)-z^{k}{att}(\\hat X)||^{2}{2}$ $Reconstruction\\ Loss:\\ L_{R}=||L(X)-L(\\hat X)||_2$，$L()$表示特征提取器 $Watermark\\ Preservation\\ Loss:\\ L_{W}=1-Cos(z_{id}(\\hat X)-Arc(\\hat X), z_{seq})$，$Cos()$表示两个向量间的余弦相似度 总损失函数为$L(X)=\\lambda_R L_R+\\lambda_{adv} L_{adv}+\\lambda_{att} L_{att}+\\lambda_{W} L_{W}$，一般来说$\\lambda_{R}=10,\\lambda_{adv}=0.1,\\lambda_{att}=10,\\lambda_{W}=1$ 2.4. 模型结构 身份编码器是现成的不用训练，属性编码器和生成器要训练 3. 参考文献[1] Proactive image manipulation detection. CVPR, 2022 [2] Faketagger: Robust safeguards against deepfake dissemination via provenance tracking. ACM MM, 2021 [3] Faceguard: Proactive deepfake detection. arXiv:2109.05673, 2021 [4] Artificial fingerprinting for generative models: Rooting deepfake attribution in training data. ICCV, 2021 [5] Image-to-image translation with conditional adversarial networks, CVPR, 2017","link":"/2023/11/08/2023.10.26%20%E8%AE%BA%E6%96%87%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94Proactive-Deepfake-Defence-via-Identity-Watermarking/"},{"title":"How to write a paper（MEGUMI版）","text":"随着Submission deadline is now这几个字出现在USENIX Security 2023的投稿网站上，如地狱一般的改论文环节结束了。就像仙侠小说中的闭关修炼，随着论文从破败不堪到勉强不错，我的写作能力也有了较大突破。虽然连续七天每天改十多小时的论文很辛苦，但是这个经历确实让我收获满满。趁健忘的我还记得，我想结合这七天改论文的经历以及感想，说一下我目前理解的论文写作方法。 我将从论文的前置准备、行文思路、结构中的每个章节来讲解如何行文。 1 论文的前置准备1.1 写作逻辑在写论文之前，需要首先定下文章要素，从而梳理写作逻辑。我总结的文章要素有如下几个： background：本工作研究领域的背景，有什么需求 motivation：现有解决该需求的方案有什么缺陷 method：论文使用的技术，设计的方案 advantage：论文的方案有什么好处（呼应motivation） challenge：为了达到这些好处遇到的难题，如何解决（和drawback的区别：drawback是现有方案本就存在的老问题，challenge是使用新技术解决drawback时会引入的新问题） contribution：advantage和challenge 把文章要素用一些过渡句串起来串起来形成写作逻辑：background的需求诞生了一些现有方案（background）。但是现有方案有些缺陷导致不能很好地满足需求，本文想要解决这些缺陷（motivation）。为了解决缺陷使用了什么技术，设计了什么方案（method）。这个method有什么好处（advantage）。但是由于引入新技术会造成新的问题，方案中如何解决新问题（challenge）。我们的贡献如下：（contribution）。 1.2 定义符号在写论文之前预先定义符号可以避免符号冲突，节省很多写作时间。定义符号具体工作分为如下两点： 定义字体：哪些字体表示哪些类型，比如粗体 $\\mathbf{a}$ 表示向量，等线 $\\mathtt{A}(\\cdot)$ 表示函数 定义符号：哪些符号表示什么意思 2 行文思路论文本质上还是八股文，行文思路较为固定，按照结构往上面填空就行： 一篇论文大致有如下部分： Abstract：用最简单的话总结论文，包括background，motivation，method，contribution Introduction：Abstract的细化 Related Work：论文中使用的各项技术的现有工作 Preliminary：在引入具体方案之前需要让读者知道的知识 Definition：从背景到motivation再到method的转折段落，用于进一步解决读者的疑惑 Method：论文中提出的具体方案 Analysis：从理论上分析contribution，比如证明密码方案的安全性、AI方案的有效性 Experiment：做了什么实验，有哪些结果，对结果进行分析 写论文需要以贡献为核心，围绕贡献进行行文：摘要说明贡献，引言总结贡献，相关工作铺垫贡献，先验知识帮助读者理解方案进而理解贡献，问题定义说明研究问题再次强调贡献，具体方案表明贡献，实验和分析证实贡献，总结突出贡献。 3 Abstract摘要中简短说明background，motivation，method，contribution等要素，行文顺序如下所示： 一句话说明研究背景，然后一句话说明motivation（如果有多点motivation就用逗号隔开或者用and等来合并） method，只需要说明用了什么技术（如果用了什么办法可以用很短的句子来概括那也可以加上）。 contribution，它的篇幅在abstract中占比最高。 对于安全的论文，一般摘要的最后都会说类似的内容：安全分析说明了方案具有足够安全性，实验结果说明方案具有足够的效率，但是任何论文都可以这样说，并不具有论文本身的特色。我们可以将这句话中加上能让读者一下就get到的具有方案特色的关键词，来体现出论文本身的特色。 摘要的篇幅通常在200个单词以内，在有限的篇幅里让读者获悉论文大体的全貌比较困难，很考察英文写作功底。解决这个问题有一套我总结的比较通用的办法，我们可以先通过要素列出一个较长的摘要然后剪枝，具体方法可以参照如下几点： background只留一句 motivation着重突出现有方法的问题（由于篇幅限制可以不说明），后果尽量用名词性短语描述，然后利用连接词或者从句拼到同一个句子中 如果篇幅依然较长，method只列出最主要的技术，并精简地说有什么advantage 说明解决了什么challenge（这里也可以看情况删去） 实验和安全证明的结果如何 4 Introduction引言是摘要的进一步扩充，读者在读完摘要的时候对方案的background，motivation，method，contribution依然比较模糊，需要引言来继续深入。 引言需要萌新友好（特别是交叉领域，比如AI和密码的交叉，AI的读者不知道密码学的概念，密码学的读者不知道AI的概念）。我看很多写论文的文章都在说，写作的过程中，把自己当作小白，反复读引言，如果自己认为读不明白就需要换一种表达方式。这说着简单实现起来却非常难，首先，引言的目的是让读者进一步明白要素的内容和之间的联系，如果一板一眼地、一句接一句地分析因果可能会造成文章语言啰嗦；其次，引言中需要尽量避免使用过于专业的或者是论文新造的词汇，如果有就需要对专业词汇做出足够精简的解释。 这导致写引言时不能不能过于深入分析导致语句啰嗦，同时不能通过自己提出的名词或者过于专业的词汇来精简引言的表达，因为考虑到读者不一定有相应的知识积累，可能不能获悉想要表达的意思。最简单的解决办法是在引言介绍background和motivation的时候把introduction中要用到的名词顺带介绍一下（比如在说motivation时，现有方案把二进制串作为水印嵌入到模型中，读者就能知道水印是潜入到模型的二进制串，既介绍了现有方法又帮助读者学习到了水印这一名词），在引言后文用到名词的时候就不用再特意介绍。读者读到引言后文遇到对应名词时可以根据前文有个大致概念。 引言的行文： 第一段介绍研究背景 第二段介绍现有研究工作以及大致实现流程 第三段介绍method，如果需要的话，可以在介绍method过后简单说一下这项工作的challenge是什么，自己是如何解决的 第四段分点总结contribution 4.1 第一段介绍background是什么，用于什么地方，目前有什么问题。 第一段相对比较简单，需要注意的要点只有说服力。说明增强说服力的几种方式： 根据目前热点事件来说明 引用参考文献：\\cite{xx} 从理论上来论述：为避免篇幅过长，在引言中简单说明，然后\\ref到具体介绍的章节 4.2 第二段介绍现有方法尝试解决这些问题、分点列举缺陷（你们的motivation） 注意： 其他方案的方法的描述越简短越好，因为这是别人的工作，不是重点。 motivation的描述需要分点，读者可以通过Introduction很快get到你的motivation有几点，分别是什么。 例子：motivation 现有方案需要可信第三方 现有方案不具有可证明安全性 。。。。 具体说明motivation分点时，需要适当深入到具体会会造成什么问题。 例子：虽然目前已经提出了一些解决background的方案，但是现有方案需要可信第三方。该例犯了motivation不够深入的问题。读者（特别是零基础的或者交叉领域的读者）很容易出现一个疑问：为什么需要可信第三方是现有方案的问题？ 修改一下上述例子：虽然目前已经提出了一些解决background的方案，但是可能遇到xx安全问题，现有方案需要使用可信第三方来避免该问题。在现实，对验证者过分的信任可能会导致隐私从第三方泄露。修改后，读者很容易地知道现有方案有隐私泄露的问题。 同时，motivation的行文需要注意篇幅和深刻程度的权衡，深刻阐述的同时对句子进行压缩。 4.3 第三段第三段首先要介绍利用什么技术，怎样实现了一个怎样的东西，然后和上一段提出的motivation相呼应，来简单阐述论文解决了现有工作的缺陷。 具体步骤： 用一句话简单介绍method用了什么技术，具体使用方法 呼应motivation，对motivation中的每点都要说明由于方案具有什么性质，所以能解决motivation的问题 接着说明challenge，达到这项好处会遇到怎样的挑战，如何解决 这段要注意的地方并不多，语言尽可能精简，避免使用前文没有出现的过于专业的或者自己提出的词汇让读者困惑就行。 4.4 第四段总结自己的contribution，分点列出来，表达的意思在和前文保持一致的同时做到尽可能精简（同时别过于精简造成contribution没表现完）。 5 Related Work相关工作感觉要注意的地方不是太多，每个文献简要说明做了什么有什么贡献。按照一个技术一个subsection来分点，每个subsection最后说明现有技术还有还有哪些问题有待解决等内容，进一步突出自己的contribution。引用的文献尽量引顶刊顶会。此外别因为别人的工作和自己的太相似，就不引用，不然可能因为这一点被拒稿。 6 Preliminary先验知识需要首先说明符号规范并列举文中用到的主要符号，然后介绍需要哪些方向的基础知识（密码学、AI）。 为了避免自己表达错误造成读者误解，写基础知识时需要参考其他文献的表达方式，并用自己的语言重述（即使有自己提出的一些新理论，也需要参考灵感来源的相关文献），进而更加准确的向读者传递新工具的各种性质。同时，其他人提出来的工具需要cite参考文献，不然读者可能会误以为是自己提出来的。 7 Definition虽然Definition内容和Introduction中的内容差不多，但Definition需要在读者已经获取了Preliminary下，对方案的问题和系统进行进一步更加详细的定义。具体需要按照问题定义、系统模型、威胁模型（或安全模型）来阐述。 7.1 问题定义继续深入说明background、motivation以及其他的东西。引言相当于在店门外的吆喝把食客吸引来，问题定义相当于服务员为走进店门的食客介绍菜品和本店特色。 引言由于篇幅有限且不能使用自己制造和太过专业的词汇，可能导致对background和motivation只能说个大概，而读者在有了Preliminary的积累之后就可以对读者进行进一步的介绍。比如： 现有xx攻击，大概的攻击方法； 现有方案为什么有如上缺点 我们的方法用了哪些技术，为什么能解决这些问题 实现这些基础有什么challenge，我们是如何解决的 由于问题定义中有很多结论性的句子，需要在这些句子中cite参考文献增加文章的说服力 7.2 系统模型系统模型主要说明系统中的实体有哪些，简要说明每个实体的任务。说明任务不必按着方案一板一眼地说，否则可能会造成懂的读者能看懂，没懂的读者看了也不知道在说什么。用联邦版权验证来举例子： 错误示范： 联邦中分为三个实体：客户端、服务器和验证者。 客户端负责生成水印和训练模型，并把模型和水印上传给服务器，并嵌入全局水印 服务器获取客户端的模型和水印，聚合成全局模型和全局水印，将他们发给客户端 验证者获取可以模型和服务器发送的全局水印，于客户端交互验证客户端对水印的版权 上述示范就是按照方案一板一眼地说，想通过简单几句话把方案说清楚，这并不现实。懂了方案怎么做的读者看到这里没毛病，没看方案怎么做的读者看到这里也看不懂，对理解论文没有帮助不说语句还啰嗦。在系统模型中我们只是想要说明每个实体要干什么，而不是说明他们之间的交互过程。 正确示范： 联邦中分为三个实体：客户端、服务器和验证者。 客户端负责训练模型，提交本地模型和生成水印 服务器负责联邦聚合和水印聚合 验证者负责验证对客户端对可疑模型的版权 这样修改读者可以很直观的看到每个实体的作用。 7.3 威胁模型对于系统模型中各个实体的信任假设：可信、半诚实、恶意，这里的信任假设在能自圆其说的前提下越严格越好，不然投安全会的话会被审稿人抨击信任假设过强（说多了都是泪）。 攻击者的攻击能力：攻击者具体可能发起哪些攻击手段，一一列举并说明，对别人提出的攻击得有文献cite，花较短篇幅来说明；对自己提出的攻击需要说明是自己提出的，并花更多的篇幅来说明。 7.4 安全模型对攻击者的形式化定义，一般来说，提出一个cryptosystem都有现成模板。如果有自己提出的安全模型建议放到分析部分，并在引出安全模型之前，分析为什么安全模型得这样构造。 8 方案方案部分的结构如下：首先总体说明流程，然后再分点详写。期间需要保持符号统一，以及直观表达。行文时不能平铺直叙，需要介绍一个环节后突出对应的contribution，比如通过这项技术能达到什么样的好处，能解决什么challenge，简单地分析一下原因（详细分析放到analysis部分）。 8.1 符号统一由于写具体方案时，为便于描述，往往会修改（包括增加、删除、改名）在Preliminary中预先定好的符号，需要更新预先定好的符号。改符号很蛋疼，简直是牵一发而动全身，改一次符号就要在全文搜索符号出现的位置，把这些符号都改一次。 修改符号有很多种原因： 符号表述不清，需要更清晰的表达（比如加下标） 符号冲突（一个符号表示多个含义） 符号不规范（向量没有加粗等） 在一开始就定义好方案中哪些变量对应哪些符号，哪些符号需要下标表示，各符号的字体是什么等，定义好符号后记得找是否有符号冲突。这样可以大幅缩减写论文中途改符号的次数，提升论文写作效率 8.2 突出贡献写方案并不是单纯为了让读者知道论文是怎么做的，还得知道论文为什么这么做，进而突出contribution。写方案的时候需要避免单纯地平铺直叙方案的流程。 举个例子：比如在写方案的时候常常会一个步骤分一个subsection。每个subsection最开始需要一一两句话对这个步骤做总领，在总领中就可以说明用到了什么技术，有什么好处（和contribution相对应），这样能加深读者对这论文的contribution的认知。 分析和实验感觉这部分没啥好说的，主要看自己理论的基本功，保证表达顺畅就行。 对分析：在保证正确性的前提下，把分析表达的直白明了，在contribution对应的部分着重强调contribution。 对实验：实验的图表尽可能多（越多的图标代表越多的工作量），在讲解实验结果的时候也要和方案部分一样突出你的贡献、效率和有效性。 10 总结 说明论文主题 归纳用了什么技术 强调contribution 11 补充11.1 \\ref引用由于读者在读到文章某个部分的时候，可能并没有需要的信息储备（比如在Introduction中读者的信息不足，可能不知道你具体在讲什么；或读者读到中间，已经忘了之前讲过什么）。这时通过引用对应图表、章节，可以让想了解具体信息的读者直接跳转到对应页面，有助于读者阅读论文。 同时\\ref还可以帮助突出contribution。比如在Introduction的最后一段总结contribution时，可以\\ref到详细分析该contribution的章节，说明contribution有实际的分析，让读者可以直观地感受到。 后记由于我目前才完成了三篇论文，对写论文的理解目前较为片面，如有不足之处还请海涵。如果之后有写论文的新感悟，我将继续更新这个文章。 2023.10.9更新：今年我已经连续吃了USENIX Security, ACM CCS, ACM MM, NDSS, AAAI 五篇拒信了。联邦场景相关的setting不明确以及水印鲁棒性的实验不全面成为了论文被拒稿的主要原因。但每个审稿人都对我的安全证明赞赏有加，这至少是对我负责部分的肯定，也算一些微小的慰藉。总之，投论文真的是很看运气的事，希望再战USENIX Security能顺利吧，不行就转投TDSC了。","link":"/2023/11/08/2023.2.9How%20to%20wirte%20a%20paper/"},{"title":"Gensyn-分布式深度学习的高效计算协议","text":"Gensyn是一种分布式AI模型训练的协议，利用模型并行进行分布式训练、IPFS进行数据集分发和存储、学习证明确保训练的真实性和有效性，加密货币进行激励。 Gensyn的背景 大模型训练需要大到难以供应的算力，比如GPT3的训练用了1000个V100，需要一种方法来集中算力 现有中心化算力出租平台价格较为昂贵，不够经济 ML训练和使用依赖于状态，需要新的的并行化和验证方法 链上直接进行模型训练效率太低 在这样的背景中，设计大规模分布式深度学习的高效计算协议分成了五个挑战： 如何验证深度学习训练工作是否真实且正确地执行 建立完善的市场机制 估算训练所需要的实践 隐私的设计 并行化训练模型的办法 Gensyn的设计功能Gensyn想要利用区块链等技术实现一种去中心化的大规模分布式深度学习的高效计算协议，具有如下功能： 概率学习证明：证明ML训练的正确性和真实性 加密货币激励机制 实体具有如下实体：提交者、解决者、验证者和举报人 提交者：提供要计算的模型训练任务，并按照完成的工作对解决者付费 解决者：执行训练，并生成训练证明 验证者：将非确定性训练过程与确定性线性计算联系起来，判断训练的正确性和真实性 举报人：检查验证者工作并提供质疑 步骤任务提交提交者提供任务和超参数的元数据、模型二进制文件以及可公开访问的数据集。这里的数据集存储在中心化或者去中心化的平台中，比如亚马逊或者IPFS 提交任务时，需要先估计需要的工时。利用类似于ETH中的Gas机制来付费，多的退出来，少的不管了 提交者将较大的计算工作拆分成任务集，异步推送到网络 训练任务进入公共池，解决这选择要执行的任务，该任务从池中移除。使用提交者提供的元数据、模型、数据集执行任务。执行训练任务时，每到一定的检查点就生成学习证明并存储训练过程中的元数据 验证证据任务完成后，解决者向链通知任务完成并公开他的学习证明，验证者从任务池中获取带待验证的任务进行验证证据，根据生成的距离是否在阈值中进行匹配 基于图形的精确性挑战举报人可以重复验证器的工作，检查验证是否正确。如果举报人认为验证执行有误则提出仲裁，如果是真阳性就获取奖励，如果是误报则从奖库中提取。 合约仲裁当验证者受到举报人的挑战时，他们会与链上合约一起进入一个流程，以缩减有争议的操作或输入的位置，最终由链上合约执行最终的基本操作并确定挑战是否合理。 结算如果工作被认为已正确执行并且所有检查均已通过，则求解器和验证器都将根据执行的操作获得奖励。 以下是各方案训练一小时的开销统计，Gensyn在较为便宜的开销下实现了高扩展性 下图是模型训练100轮的时间开销统计，时间开销相比直接训练增加了50% 问题和启发Gensyn存在的问题 没有具体设计模型如何并行 训练的真实性依然依赖于可信的举报人，没有实现真正的去信任 即使举报人发现了验证结果有误，错误的训练结果可能已经影响了之后的模型训练 直接估算工作量不一定准确，文中说是按照ETH中Gas的办法来按照消耗的算力付费。但是模型训练很看重效率，要是Gas的钱没给够直接导致本次训练任务作废，导致整轮训练等待一小部分任务重新完成很影响效率。同时为了保证所有计算任务都完成，一个小任务给很多Gas可能造成并行的训练任务数减少，降低学习的效率 需要高效的验证训练证明的方法 一些想法利用区块链的算力进行分布式模型计算有两个根本问题需要解决： 如何实现模型分布式训练（模型并行，数据并行，流水线并行，张量并行，零冗余） 如何快速验证模型训练效果 局域网分布式训练的想法由于节点局域网内网络IO可以忽略不计，并且单个节点可以完成整个模型训练。此时完全可以让节点把训练封装（模型并行），提交者发送待训练模型，并返回训练后的模型，提交者可以利用现有方法来验证模型训练效果。 但局域网内有缺点：局域网内的显存有限，难以对参数量日益增加的模型进行训练。 跨域分布式训练的想法跨域分布式训练可以把不同矿场的算力和显存集中，进而训练更大的模型。但跨域分布式训练还有如下的问题： 网络IO延迟大，需要尽可能减少跨域传输的数据量（降低梯度传输）； 对于一个节点都装不下的超大模型，需要结合各种模型并行技术； 张量并行和流水线并行需要将模型拆为多个碎片分开训练，由于碎片的最优输出难以确定，利用测试集打标签的做法不可行，难以从测试集上判断模型训练质量。","link":"/2023/11/08/2023.3.3Gensyn/"},{"title":"98探索🍺——北河三Pollux","text":"我写这种闲谈一般没啥逻辑可言，想说啥就说啥。 我于2022年6月在B站刷到了北河三老板老板Carson介绍鸡尾酒的视频，当时看了他系统的讲解后感觉对鸡尾酒的了解收获蛮多的（但并没有关注他）。再一个月之后，我又在B站刷到了他在成都开了家名字叫北河三的酒吧的视频，当时就有了探店的想法。但由于本人的行动力过于低下，即使有Casio陪着我去喝酒也只去过两次北河三，一次在23年2月，另一次在23年9月。 虽然来喝酒的次数少，但这两次我都被Carson的鸡尾酒深深折服。另外，这里不仅酒挺好，陪着我的人更是nice，Casio在喝酒时传递的信息以及对于业界的各种看法让我豁然开朗，稍微吹开了我内心困惑的乌云。这篇闲谈会先评价北河三的酒，然后再记录一下当时Casio向我传递的比较有价值的观点以及自己的思考，以便自己之后再迷茫时可以借助这些方法论来思考和分解问题。 1 北河三的酒我来北河三总共喝了三种鸡尾酒，月球漫步改、贝雷帽、xx号火箭（忘了具体是多少号了）。我最喜欢的是前两个。 月球漫步给我的感觉是很华丽的妹酒，它杯口上的气泡也确实就像月球上面那些大坑，气泡上的青柠皮屑和那朵花使得人一喝酒时有股沁人心脾的清香。它总体上的味道有点像Last word，我和Carson聊这杯酒的时候，他说他改进月球漫步的时候，并不只是单纯想朝着妹酒来做，反而他想在酸甜的酒中加入一些其他特别的风味，而不是只有酸甜。我当时想了想，或许这就是他在酒的泡沫上放青柠皮屑和花的原因吧。总体来说，这款酒从风味、外观和香气上来说都非常棒，有股六边形战士的感觉，应该每个人来都会喜欢上这杯酒吧。 和月球漫步改相比，贝雷帽可能就不是那种合家欢类型的酒，它主打咸湿的风味我觉得并不能让很多人接受。当时看酒单的时候，我看到贝雷帽用到了一种口味偏咸的辣椒和发酵的菠萝，酒杯上还有盐边，这让我乍一看根本猜不到这杯酒的味道，但因为加藤惠喜欢带贝雷帽，所以我就点了这杯酒。第一口给我的感觉首先是酒体的口感很浓厚，然后味蕾被发酵菠萝和柠檬的风味占据，再然后是酒杯口的盐和青柠屑被酒体带进嘴巴带来一种咸但清香的感觉。喝完第一口后调酒师让我试试吃一颗下酒的辣椒，辣椒的味道更加突出了这杯酒咸的主题。喝这杯酒的时候让我感受到了在美国西海岸抽雪茄的感觉，酒的风味就像西海岸咸咸的海风，而辣椒的风味就像是雪茄。（感觉盲盒开对了）。 至于xx号火箭，我觉得它的口味比较平淡，我并不是很喜欢，目前也忘了这杯的味道是咋样的。 另外，Carson的边牧真的超级聪明，我一入座，它就像营业一样把手伸过来让我摸。为什么说是营业呢？因为它根本就没看我一眼😡！ 2 Casio观点的大致总结酒介绍完了，现在开始聊正题，这次喝酒我向Casio请教了很多关于实习和工作的经验和信息，总体上来说他的观点我比较认同，他的核心观点主要有三个： 收集足够的信息（我觉得收集信息主要还是着重社交然后向认识的人问情报，目前我遇到的CS圈子里的人都蛮nice的，大家都很乐意交换情报），明白自己的目标，然后每一步行动和选择前想清楚它如何服务于你的目标（类似5W1H吧） 向上思考，明白上级这么做的动机 技术过了招聘门槛就好，相信自己的能力 第一点第一点我已经深有体会了。四月份我正在焦虑的时候，我想问问本科老板关于生涯规划的问题，但老板反问我一句你想要什么，我竟然一时答不出来，那时我才明白，我连自己的目标都不知道是什么，又怎么进行生涯规划呢。好在目前我知道了我大致想要什么样的生活，也确实在朝着这个方向行动。 第二点第二点是我重点想说的，虽然我现在对这点的认识仍然不够深，在了解需求这方面，我的还有很大的进步空间。向上思考确实非常重要，这可以让自己完全明确游戏规则，可以根据规则投其所好最终大大增加赢得游戏的概率。 以保研来说，套磁老师时，老师对你在哪实习过、打过什么比赛基本都不关心（很多老师甚至不知道ACM是什么），他们关心的无非就是你是否具有足够的科研能力和科研潜力来给他生产论文和本子（让他们拿到名和钱），如果你没有paper来展现你的科研能力，没有rank来展现你的科研潜力，那么你在简历上写再多的竞赛经历和实习经历都是无用功，老师不会认的。 再以企业实习面试为例，一般需要经历四次面试：技术面、Leader面、主管面以及HR面，我们忽略HR面。技术面主要是同事面，他主要是想考察你的能力是否达到了在这里实习的门槛，因为他目前还在开发的最前线，所以主要会着重问技术，因为之后他会和你一起工作，你如果没做好可能会拖他的后腿或者相处不愉快。对于Leader面，他目前并不一定在开发的最前线，在开发前线的leader会着重问技术的问题，而已经转管理的leader会着重问业务的问题。主管面就更加随意，你要去的组只是他管理的组的一个，如果他对这个组的业务比较了解就会着重问你关于那个业务的技术方面的问题。一般来说，Leader面的结果比较好的话，主管面其实一般不会刷人，Leader很想要你的话会让主管捞你，而主管知道他对这个业务最了解，也会采纳Leader的想法。 第三点第三点的话其实没啥好说的，因为去向真不是简简单单的技术就能决定的，以保研为例，信息（比如今年保研9.20号之前根本没有工程硕博这个说法，结果临近填系统几天突然多出了工程硕博的名额，导致很多人可以捡漏清华，还可以去企业恰米，香的不行但很多人都不知道有这回事）、人脉（有没有人推荐）、运气（和老师有没有对上频率啥的）都会极大的影响自己的出路，有时候明明自己更强但是出路没别人好也没啥好说的哈哈。 总体来说这次交谈收获满满，稍微吹散了我心中的疑惑，让我知道了我的焦虑从何而来。除了信息查，我也知道了向上思考也同样重要，这可以让我根据游戏规则来采取行动。这次98探索大概就写到这吧，下次98探索更新右眼所，那里既是我鸡尾酒启蒙的地方也是我去喝酒次数的最多的地方。","link":"/2023/11/08/2023.9.28%2098%E6%8E%A2%E7%B4%A2%F0%9F%8D%BA%E2%80%94%E2%80%94%E5%8C%97%E6%B2%B3%E4%B8%89Pollux/"}],"tags":[{"name":"闲谈","slug":"闲谈","link":"/tags/%E9%97%B2%E8%B0%88/"},{"name":"WEB3","slug":"WEB3","link":"/tags/WEB3/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"区块链","slug":"区块链","link":"/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"AI安全","slug":"AI安全","link":"/tags/AI%E5%AE%89%E5%85%A8/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"音频","slug":"音频","link":"/tags/%E9%9F%B3%E9%A2%91/"},{"name":"属性基加密","slug":"属性基加密","link":"/tags/%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%8A%A0%E5%AF%86/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"表达能力","slug":"表达能力","link":"/tags/%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B/"}],"categories":[{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"科研","slug":"科研","link":"/categories/%E7%A7%91%E7%A0%94/"}],"pages":[{"title":"About","text":"博主叫MEGUMI，该名出自番剧《路人女主的养成方法》的女主角加藤惠（Katou Megumi）。 目前21岁事学生，目前在电子科大读大四，已保送北深。爱好：ACG，网上冲浪，喝酒，游戏，旅游。 目前最喜欢轻百、校园、公路等题材的番剧 冲浪强度较高，平时比较喜欢搞抽象 比较喜欢干喝威士忌和以金酒为基酒的鸡尾酒（特别是干马天尼） 平时压力大或者闲下来会打打mc，平时比较喜欢打极地大乱斗 喜欢以露营的方式旅游（因《摇曳露营》入的坑，现在只露营过一次还是萌新） 目前在从事密码学、AI安全和音频领域的研究，致力于将密码技术应用于网络安全、AI安全、区块链安全等领域。 竞赛获奖（成果很捞）： 2023年中国高校计算机大赛网络技术挑战赛国家三等奖 2022年中国高校计算机大赛网络技术挑战赛国家三等奖 2022年中国高校计算机大赛网络技术挑战赛西南赛区二等奖 2023年中国高校计算机大赛网络技术挑战赛西南赛区第二名 学术成果： 设计并实现了首个跨度隐藏的属性基加密算法 设计了首个基于零知识证明的AI模型版权验证方案，为模型版权验证领域带来了凭证隐藏和理论安全证明 设计了首个基于数字签名的联邦模型版权验证方案，该方案可以有效抵抗歧义攻击，且水印嵌入效果不会受到客户端数量的影响。 虽然目前没有正式论文发表，但是我还差S&amp;P就集齐安全四大的拒信啦 哈哈哈哈😭。 USENIX Security 2024 在投 IEEE TPAMI 在投 博客主要用于分享技术、生活以及一些感想。技术方面主要分享AI和密码相关的技术及其应用，希望能帮到想要了解相关领域的人。 最后，本人目前写作的逻辑能力提升空间极大😭，希望能借助博客提升自己的写作能力。","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}